[["index.html", "Natural Language Processing for the Social Sciences Preface", " Natural Language Processing for the Social Sciences Remy Stewart 2021-11-16 Preface Welcome to the Natural Language Processing for Social Sciences User Guide provided by the Cornell Center for Social Sciences (CCSS)! This guide serves as both the written version of Spring 2022’s workshop under the same name as well as a standing reference available to wider Cornell community. Are you… Not too familiar with NLP and are looking for a broad view on the discipline as applicable to social sciences? Curious about ways you could potentially incorporate NLP into your research? Know enough R to understand its basic syntax? In search of simple and interpretable R code to get you started on using NLP? If any of these are true for you, I think you’ll be able to get something out of this guide. This guide is heavily inspired by a whole series of similar works designed to introduce NLP to social scientists or for providing code demos in R for various NLP tasks. Almost all of these resources go further into depth on the topics introduced within this guide and I highly recommend them all as additional references. A little about the author- my name is Remy Stewart and I am both a PhD Candidate in the Sociology Department here at Cornell as well as a Data Science Consultant for CCSS. I use NLP extensively within my own research that investigates how technology impacts public policy and perpetuates inequality within US urban regions. This work therefore unavoidably reflects my own disciplinary training biases, but I intentionally designed it to be as widely applicable to readers across social science fields as possible. You’ll be able to navigate through the individual chapters of the guide through the index to the left. The chapters do build from each other particularly regarding the core concepts and coding components, but can stand alone for each topic as well. "],["intro.html", "Chapter 1 Fundamental Concepts 1.1 Text as Data 1.2 Natural Language Processing 1.3 Computational Social Sciences 1.4 NLP Core Vocabulary", " Chapter 1 Fundamental Concepts 1.1 Text as Data Text is a seminal communication medium within and produced by human interactions and social systems and has been a longstanding data source in social science research. However, text data has often been associated with qualitative scholarship given limitations of predominant quantitative methods for handling text and language. While the numerical analysis of text has been of ongoing interest of fields such as linguistics and information retrieval for decades, the employment of computational text analysis methods across a variety of disciplines has been a comparatively recent phenomenon. Said diffusion of the quantitative study of text is intimately tied to the Digital Revolution’s concurrent facilitation of the accessibility of text data as well as ability to model said records within computationally-powered analyses. Digital traces or footprints refer to the records individuals leave behind of their behavior, thoughts, relationships, and beyond that are digitally recorded and often acquirable by third parties (Golder and Macy 2014). Text data is one of the most common types of digital traces as facilitated by the sharp rise of internet use, particularly as regarding social media platforms. Consider the following trend as visualized by Our World in Data of just how ubiquitous social media has become globally- While some of these platforms focus more on image and video content over text than others, all of them have at least some degree of text produced that is often publicly accessible. Plenty of additional websites such as online marketplaces or business and government sites also produce ample amounts of text to be used within social science research. Beyond internet mediums on their own is also the concurrent shift of preexisting print documents to digitized forms as well as the production of more recent documents to now be available online. Newspaper archives, government records, and books across languages are all examples of these sources. Researchers can now analyze historical documents through new methodological approaches through their digitized versions as well as connect published material across time from decades-old records to modern day. From 1996 to 2021. Source: New York Times. 1.2 Natural Language Processing The rise of the internet and its ubiquitous cataloging of produced text is concurrent to the growth of resources and methods to computationally explore said written records. Natural language processing- shortened to NLP- is the field that specializes in using computational tools to interpret human language. NLP itself refers to a broad range of applications including speech and handwriting recognition, text generation, translation, and beyond. NLP methods range in complexity from simple counts of word occurrences to the ability to generate accurately predicted words through machine learning-powered artificial intelligence. Recent advances in NLP have increasingly been able to engage with more complex questions regarding text, such as the context words occur in, their conceptual similarities to other words, and the potentially multiple meanings of a given word. NLP and its respective methods can often be computationally resource intensive for storing, processing, and interpreting text. These barriers limited its more widespread adoption within research across fields such as the social sciences, along with barriers regarding learning new programming languages and computational skills. Advances in the availability of computing resources have significantly speed up what may have otherwise be painfully slow algorithmic analyses and have made storage systems to save massive collections of text data widely available. The open-source software development movement has additionally lead to innovations in programming resources to employ NLP that are free, methodologically rigorous, and often more accessibly designed to learn. 1.3 Computational Social Sciences The subsequent recent adoption of NLP methods within social science research is a subset of the wider disciplinary establishment of computational social sciences (CSS). Lazer et al. defines CCS as the “development and application of computational methods to complex, typically large-scale, human (sometimes simulated) behavioral data” (2009: 721). CCS spans a wide range of topics beyond text data analysis via NLP with additional core areas including online community network analysis, geospatial tracking, agent-based modeling, and many more examples. However, CSS is particularly well-aligned with NLP methods when considering how much information on human behavior is embedded within text. A particular strength social scientists offer when conducting CSS research with NLP methods is their personal expertise towards interpreting often nuanced and contextualized findings within text data. Social scientists have therefore been on the cutting edge for conducting NLP-powered research across diverse topics and have formed related communities within universities and conferences connecting CSS and NLP practitioners. Word embeddings from Kozlowski, Taddy, and Evans 2019 &amp; Structural Topic Models from Wilkerson &amp; Casas 2017 1.4 NLP Core Vocabulary This guide will offer an introductory demo of how to apply NLP within your own research via R. Before moving to the guided applications, we must review a series of common terms within NLP that this guide will refer to. I’ll ground said terminology by first reviewing the dataset that all of the following chapters will use and is available on the guide’s GitHub repository. Our dataset is 100,000 comments scraped from “r/nyc” which is the largest community on the social media site Reddit for posts and conversation around anything related to New York City. I obtained these records through a recent call at the time of writing to the Pushshift Application Programming Interface (API) created by Jason Baumgartner. Reddit is known as the “Front Page of the Internet” and it is one of the most common social media sites studied within NLP research. Features of the platform that contribute to Reddit’s popularity within NLP is that its data is accessible to acquire, it features a range of sub-communities of potential interest, and it is a particularly discussion-orientated platform. I also note that using Reddit data- as is the case with virtually all publicly accessible online trace data- comes with its own ethical considerations regarding privacy, sensitivity, and expectations around use within research. Please refer to the “Ethics” section in the final chapter of this guide for further thoughts around said topics. Landing page of r/nyc. Now that we’ve familiarized ourselves with our dataset, let’s consider how we would refer to its respective components through NLP terminology. A corpus refers to the total collection of text being analyzed. This would be all 100k of our r/nyc Reddit comments. A vocabulary is the entire collection of unique words that occur within a given corpus. A document is an individual record within the corpus. This would be one particular collected r/nyc comment and all of its associated text. An example would be “My favorite pizza place in Hell’s Kitchen is 99 Cent Fresh Pizza. I really love their BBQ Chicken Slice.” Tokens are the smaller composite units within a given document. “Tokens” on its own most commonly refers to individual words, but the actual process of tokenization can feature larger units such as sentences or paragraphs. When referring to the tokens of the document example above, “My,” “favorite,” “pizza,” and “place” would be considered as four separate tokens of the 21 total tokens including the sentence’s periods. However, another NLP method may instead operationalize this comment’s tokens as “My favorite pizza place in Hell’s Kitchen is 99 Cent Fresh Pizza.” and “I really love their BBQ Chicken Slice.” Tokenization can also be conducted to character-level granularity, such as “p,” “i,” “z,” “z,” “a”… and following through all other words within the comment. N-grams considers multiple word tokens at once where “n” refers to a specified number. They are often employed for representing words that are conceptually different when considered as a whole unit rather than as individual tokens. The bi-gram of “Hell’s_Kitchen” is understood as a specific neighborhood through each word’s co-occurrence with each other than what “Hell’s” or “Kitchen” would imply on their own. These are the core terms necessary for an initial engagement with NLP methods and are often referred to directly within the R software packages we will be using in the following demos. With our core understanding of NLP and our dataset now cemented, let’s move on to our first key step within our text data analysis starting with text preprocessing in the next chapter. "],["textproc.html", "Chapter 2 Text Preprocessing 2.1 Character Encoding 2.2 String Cleaning 2.3 Regular Expressions 2.4 Lowercasing &amp; Concatenation 2.5 Tokenization 2.6 Optional Method-Dependent Preprocessing Steps", " Chapter 2 Text Preprocessing Preparing text data for NLP analysis presents unique challenges. Text can vary significantly in degree and components of “messiness” compared to other common data types depending on where it was sourced from, what types of information is being expressed, and what elements of “noise” as in unwanted components within the text may be present. Text preprocessing refers to the wide variety of techniques to prepare your text data from its starting point of being loaded into your program to a form ready for whatever methods you’d like to apply to your text. The preprocessing steps you use are therefore highly dependent on both your individual dataset and the specific means of analysis you’re planning on for your text data. Some preprocessing methods are for much more specific use cases, while there’s a general set of recurring techniques often required for NLP applications. I’ll also introduce a core theme within NLP in this section that you’ll find throughout this guide in that NLP research findings are often heavily defined by previous choices you make in your research workflow. Text preprocessing decisions are one of the biggest examples of this. How you decide to prepare your data can make a significant impact on the results you obtain further in your research. I will therefore provide an overview of a wide range of preprocessing options and encourage you to test out a variety of these for your specific use cases. This is key to ensure the robustness of your findings to various text specifications and will strengthen the rigor of your research overall. This demo focuses on four of my go-to R packages for NLP research that all stem from the tidyverse collection by Hadley Wickham and his team at R Studio. These packages are designed to be easy to understand &amp; implement and they seamlessly build from each other for various tasks relevant to your data preparation. readr facilitates the easy uploading of external data files such as CSVs into R while dplyr promotes streamlined data frame creation and manipulation from said files. stringr is all about working with character strings which is the data type that text falls under. tidytext provides more specialized functions to prepare text data for various NLP use cases. I’ll go ahead and load all of these packages into our working session under the assumption of them being previously installed to your local machine through the install.packages() command. I’ll also read in our r/nyc dataset from the provided CSV file sourced from this guide’s Github repository. I recommend that you create a folder on your computer that holds both the CSV data and a saved R file titled “text_preprocessing.R” in one location. library(readr) library(dplyr) library(stringr) library(tidytext) ## EDIT THIS PATH FOR FINAL GUIDE LAUNCH nyc &lt;- read_csv(&quot;nyc_reddit.csv&quot;) 2.1 Character Encoding Character encoding refers to numerical codes designed for programs to know how to display a text character. Particularly messy text sources such as website scrapes can lead to datasets that follow different types of character encoding schemes. This can create issues for reading in and manipulating text within a given program and/or method application. Most English text data is used with either Unicode/UTF-8 or ASCII encoding, and we can check if our dataset of r/nyc comments follows one of these encoding schemas after loading in our data. guess_encoding(nyc$body) ## # A tibble: 2 × 2 ## encoding confidence ## &lt;chr&gt; &lt;dbl&gt; ## 1 UTF-8 1 ## 2 windows-1252 0.68 Our 1 confidence score on the UTF-8 encoding for the text column of our data frame gives us assurance that the following preprocessing methods should work without issues around character encoding. Let’s now inspect our dataset in more detail. nyc ## # A tibble: 100,000 × 5 ## id author body score date ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2666 chillwavexyx &quot;Not just my experience, unfortunately. Very hard t… 1 11/4/… ## 2 30225 MG7444 &quot;Was Joe Biden disciplined? AOC? Any of the Democra… -10 10/21… ## 3 85724 robswins &quot;Imagine if cities actually used police like this. … 27 9/20/… ## 4 13927 nydutch &quot;No, it really, really is not. I don&#39;t see any hooo… 1 10/30… ## 5 117584 kittygirl9891 &quot;I&#39;m so worried about my car. It&#39;s parked in a base… 7 9/2/21 ## 6 100790 Darrkman &quot;Oh lord. \\n\\nI bet you&#39;re 30 yrs old at the oldest… 1 9/10/… ## 7 69805 Solagnas &quot;You inferred wrong, idk what to tell you man. Its … -2 9/28/… ## 8 138396 TheNormalAlternative &quot;Last I checked, this bridge was 30 miles north of … -6 8/20/… ## 9 125491 couchTomatoe &quot;Yes, I said that. Every corner.&quot; 2 8/27/… ## 10 96017 twelvydubs &quot;Earlier in the year we already extended WFH to ear… 19 9/13/… ## # … with 99,990 more rows This provides us with the first 10 records of our dataset. “id” is the unique identifier for each individual comment, “author” provides the Reddit username who wrote the comment, “body” features the text of the comment itself, “score” refers to the Reddit system of being able to “upvote” or “downvote” comments similar to a like/dislike framework, and “date” as the year, month, and day the comment was posted. Our preprocessing will focus on “body” as the main text data feature of our data. 2.2 String Cleaning String manipulation is key to virtually any form of cleaning you may need to implement for your data to remove unwanted noise within text and represent a given document in a more interpretable form. This is where functions in the stringr package particularly shine. Let’s first consider one semantically meaningless token found throughout our dataset referring to “” This represents line breaks within HTML web syntax that were captured as a by-product of scraping our Reddit comments. We can use stringr’s str_remove_all function to strip out all instances of directly from the comment text. nyc$body &lt;- str_remove_all(nyc$body, &quot;\\n&quot;) This successfully removes all instances of “” However, there is a variety of additional components of the text that a user may want to extract out depending on their intended NLP use case. For example, removing all punctuation is commonly desired within NLP methods since punctuation would be tokenized as their own words. Our previous method is great at removing any exact match with “” within the comments, but a more streamlined technique to remove any undesired character type would save us much more time and code lines then individually having to identify every type of punctuation we’d like to remove. 2.3 Regular Expressions Regular expressions- commonly shorted to regexes- is the core tool within string manipulation to perform more comprehensive removal operations for a variety of use cases. regexes allow you to identify patterns within text and perform operations on them. Regex design can get quite complex and successfully constructing them for certain use cases is another topic in itself. They also must be handled with care, as their potentially intricate design may end up performing manipulation on your text data that you weren’t originally intending to occur. Regexes are however a highly flexible tool for solving various problems within text manipulation. Refer to this chapter’s references at the end of the user guide for further resources regarding the potential designs and applications of regexes as well. Given that the remaining noise in our r/nyc comments features a wide variety of punctuation characters types, a regex that identifies and removes all punctuation will serve our purposes particularly well. The special regex we’ll use is [:punct:] which successfully identifies all punctuation characters. Removing said punctuation is achieved through another call with str_remove_all as follows: nyc$body &lt;- str_remove_all(nyc$body, &#39;[:punct:]&#39;) 2.4 Lowercasing &amp; Concatenation It’s common within text preprocessing for NLP to convert all words to lowercase since the use of capitalization may lead to a given method to identify the same word as separate entities based on casing alone. You may also consider explicitly combining n-grams into single word units, such as concatenating all instances of the bi-gram “New York” into the single token of “New_York.” This isn’t as commonly employed within NLP as lowercasing is, but there’s certain use cases where having n-grams explicitly connected to each other can be key to your research interests. You’ll find stringr-based techniques for lowercasing and concatenating respectively as follows: nyc$body &lt;- str_to_lower(nyc$body) nyc$body &lt;- str_replace_all(nyc$body, &quot;New York&quot;, &quot;New_York&quot;) 2.5 Tokenization Tokenization as mentioned in this guide’s first chapter refers to the segmentation of text components into a given unit of analysis such as individual words, sentences, paragraphs, characters, or n-grams. While the best type of tokenization is highly dependent on your given research questions and planned analyses, the most common tokenization unit overall are individual words. I therefore employ tidytext’s unnest_tokens method to create a separate data frame with a designated row for each individual word within a r/nyc comment. The “word” argument specifies individual words as our tokenization unit. tokens &lt;- nyc %&gt;% unnest_tokens(&quot;word&quot;, body) Our 100,000 original comments are now almost 3.5 million rows of individual word tokens. By default, unnest_tokens lowercases the tokens and removes punctuation from the original string, allowing you to skip stringr’s to_lower and having to use a punctuation removal regex if you’re also planning on tokenizing your text data through tidytext. 2.6 Optional Method-Dependent Preprocessing Steps There’s a variety of additional preprocessing techniques you may consider for your specific NLP research interests beyond the previously delineated methods. These include stopword removal, stemming, and parts-of-speech tagging. These techniques are overall more case-by-base in their usefulness than string manipulation and tokenization are as core preprocessing steps. Even methods where techniques such as stopword removal or lemmatization are common are often a source of controversy within the NLP community around whether said removal is appropriate. It’s often best to see if your results change either with or without a given preprocessing technique used before your analysis, and if they do consider said differences in the interpretation of your overall research findings. 2.6.1 Stopwords Stopwords is the term form common words such as “the,” “but,” and “is” that are often understood as contextually irrelevant for the primary purposes of a given NLP analysis. Stop word removal can be particularly helpful when you’d like to focus on unique and/or subject-specific words that often carry more in-depth meaning than more common phrases. Topic models are one form of NLP analysis we’ll be exploring later in this guide where stop word removal is quite common, as the method is usually employed to discover conceptually deeper themes within text than what semantically generic words tend to indicate. However, other use cases such as exploring how two communities differ in conversational styles may be better served by keeping stop words, since even the usage of common words can indicate meaningful differences between groups. If stop word removal seems relevant to your given research question, tidytext actually provides an established dataset of common English stopwords for you to remove from your tokenized text. This is achieved through an anti-join of your own data and the stopwords data frame, which builds from query-language data merging principles to not include words that match both datasets. It’s also important to note that this preestablished set of stopwords may not entirely translate to other common and conceptually less meaningful words within your own data. It’s therefore common to build from an initial list and perform additional stopword removal through techniques such as the previously delineated str_remove_all. data(stop_words) tokens &lt;- tokens %&gt;% anti_join(stop_words) 2.6.2 Stemming Stemming refers to reducing words to their base forms. This technique is often used to group together different words that have the same underlying root such as “swims,” “swimmer,” and “swimming” all referring to the base stem of “swim.” Stemming can be helpful to streamline vocabulary size, such as for machine learning NLP techniques where having less words that are similar to each other can cut down on processing time and necessary computational resources for running already complex models. However, said similar words via a core base root can also have very different conceptual meanings and be used in distinct contexts from each other within text that stemming may minimize or lead to a misinterpretation of. This is a technique that therefore needs to be used with particular care towards weighing both its potential costs and benefits. There’s a variety of different types of stemming algorithms available with the most commonly used being the Porter stemmer. You’ll have to download the SnowballC package separately to use the Porter stemming technique. I demonstrate its application on our previously created tidytext word token data frame below: library(SnowballC) stems &lt;- tokens %&gt;% mutate(stem = wordStem(word)) %&gt;% count(stem, sort = TRUE) 2.6.3 Parts-of-Speech Part-of-speech (POS) tagging describes the process of identifying the lexical and grammatical category a word belongs to within a sentence, such as nouns, adverbs, conjunctions, and beyond. POS tags are often used for analyses where the type of words within text is of particular importance to your research interests. Potential cases of this include how actors interact with each other as expressed in a given sentence’s structure or how the frequency of certain linguistic features within text may be predictive of an outcome. Annotating each token’s respective POS type can be used to generate counts of overall categories or discover the most common words that fall into a given lexical class within your specific text. One disadvantage of POS tagging is that it can take a long time to process an entire tokenized corpus with each word’s matching POS class. Different libraries that support POS tagging often require you to download and load a separate annotation model that maps words to their correct POS categories as well. The udpipe package streamlines this process with its concurrent library commands delineated in the following code for our tokenized r/nyc comments below: library(&quot;udpipe&quot;) model &lt;- udpipe_download_model(language = &quot;english&quot;) model &lt;- udpipe_load_model(model) ## Annotation will take quite some time, particularly if you&#39;re using the ## non-stopword version of our tokenized dataset tags &lt;- udpipe_annotate(model, x = tokens$word) ## The generated &quot;upos&quot; column in the following dataframe will have each token&#39;s ## identified POS tags. pos &lt;- as.data.frame(tags) "],["dictionary.html", "Chapter 3 Dictionary Methods &amp; Sentiment Analysis", " Chapter 3 Dictionary Methods &amp; Sentiment Analysis WIP "],["ml.html", "Chapter 4 Machine Learning &amp; Topic Models", " Chapter 4 Machine Learning &amp; Topic Models WIP "],["methodsethics.html", "Chapter 5 Additional Methods &amp; Ethical Considerations", " Chapter 5 Additional Methods &amp; Ethical Considerations WIP "],["references.html", "Chapter 6 References", " Chapter 6 References WIP "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
